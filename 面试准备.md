#### 一、预编译做了哪些事情
- 函数作用域预编译
1. 创建了AO对象
2. 找形参和变量的声明，作为AO对象的属性名，值是undefined
3. 实参和形参相统一
4. 找函数声明，会覆盖变量的声明
- 全局作用域的预编译
1. 创建GO对象
2. 找变量声明，将变量名作为GO对象当属性名，值是undefined
3. 找函数声明，值赋予函数体

#### 二、this
1. 在函数中直接使用指向window
2. 函数作为对象的方法被调用，谁调用就指向谁
3. 箭头函数里的this是外层代码块的this，本身没有this所以不能用作构造函数

#### 三、深浅拷贝
1. 赋值：把一个对象赋值给一个新的变量时，赋值的是该对象栈中的地址，两个对象指向同一个储存空间
2. 浅拷贝：重新在堆中创建内存，拷贝前后对象的基本数据互不影响，但拷贝前后的引用类型因共享同一块内存，会相互影响
``` js
function shallowCopy (obj) {
	var target = {}
	for (var i in obj) {
		if (obj.hasOwnProperty(i)) {
			target[i] = obj[i]
		}
	}
	return target
}
 ```
3.  深拷贝：从堆内存中开辟一个新的区域存放新对象，对对象中的子对象进行递归拷贝，拷贝前后的两个对象互不影响（实现：递归）
 ```js
 function deepClone (obj) {
	 var cloneObj = new obj.constructor() // => cloneObj = {}
	 if (obj === null) return obj
	 if (obj instanceof Date) return new Date(obj)
	 if (obj instanceof RegExp) return new RegExp(obj)
	 if (typeof obj !== 'object') return obj
	 for (var i in obj) {
		 if (obj.hasOwnProperty(i)) {
			 cloneObj[i] = deepClone(obj[i])
		 }
	 }
	 return cloneObj
 }
 ```
 4. A instanceof B : B的prototype of是否属于A的原型链中

#### 四、防抖
当持续触发事件，一定时间内没有再触发事件，事件处理函数才会执行一次
```js
// 闭包解决防抖，闭包：函数里return函数
function debounce (delay, callback) {
	let timer
	return function () {
		clearTimeout(timer)
		timer = setTimeout(() => {
			callback()
		}, delay)
	}
}
debounce(1000, function() {})()
```
实际应用
1. 使用echarts时，改变浏览器宽度时，希望重新渲染，可以使用此函数提升性能
2. 输入搜索：输入结束n秒才进行搜索请求，n秒内又输入当内容重新计时，可解决搜索当bug

#### 五、节流
当持续触发事件时，保证一段时间内，只调用一次事件处理函数（一段时间内，只做一件事情）
```js
function thro (callback, wait) {
	let timerOut
	return function () {
		if (timerOut) {
			timerOut = setTimeout(() => {
				callback()
				timerOut = null
			}, wait)
		}
	}
}
thro(function() {}, 1000)()
```
实际应用
1. 表单提交：鼠标不断点击触发，规定在n秒内多次点击只有一次生效

#### 六、作用域
1. 当函数动漫执行前期，会创建一个执行期上下文的内部对象AO（作用域）
2. 这个内部当对象是预编译时创建出来的，因为当函数被调用时，会先进行预编译
3. 在全局代码执行当前期会创建一个执行期当上下文对象GO

#### 七、arguments的对象是什么 —— 类数组对象
箭头函数是没有arguments对象的
```js
function get () {
	console.log(arguments)
}
get(1, 2, 3)
```
类数组对象怎么转化成数组？
```js
Array.prototype.slice.call(arguments)
```

#### 哪些操作会造成内存泄漏
1. 闭包
2. 意外的全局变量
3. 被遗忘的定时器
4. 脱离dom的引用 dom没被清理

#### 什么是高阶函数
将函数作为参数或者返回值的函数
```js
function highOrder (params, callback) {
	return callback(params)
}
```

#### 重写map方法
```js
function map (arr, callback) {
	if (!Array.isArray(arr) || !arr.length || typeof callback !== 'function') {
		return []
	} else {
		let result = []
		for (let i = 0, len = arr.length; i < len; i++) {
			result.push(callback(arr[i], i, arr))
		}
		return result
	}
}
```

#### js语言的特点
单线程 解释性语言

#### 事件循环机制（event-loop）
1. 调用栈
2. 微任务队列
3. 消息队列
- event-loop开始时，会从全局一行一行执行，遇到函数调用会压入到调用栈中，被压入的函数被称为帧，当函数返回后会从调用栈中弹出
- js中的异步操作，比如fetch、setTimeout、setInterval压入到调用栈中时，里面的消息会进到消息队列中去，消息队列会等到调用栈清空之后再执行
- promise、async、await的异步操作时会加入到微任务中去，微任务队列会在调用栈清空时立即执行，微任务队列会比消息队列早执行

#### 单例模式
- 定义：1.只有一个实例 2.可以全局访问
- 主要解决：一个全局使用的类，频繁的创建和销毁
- 何时使用：当你想控制实例的数目，节省系统化资源
- 如何实现：判断系统是否已经有这个单例，如果有则返回，没有则创建
- 单例模式优点：内存中只要一个实例，减少了内存的开销，尤其时频繁的创建和销毁
- 使用场景：1.全局的缓存 2.弹窗
```js
// ES5 登陆框实现
var getSingle = function (fn) {
	var result
	return result || (result = fn.apply(this, arguments))
}
var createLoginLayer = function () {
	var div = document.createElement('div')
	div.innerHTML = '我是登陆框'
	div.style.display = 'none'
	document.body.appendChild(div)
	return div
}
var createSingleLogin = getSingle(createLoginLayer)
document.getElementById('button').onClick = function () {
	var loginLayer = createSingleLogin()
	loginLayer.style.display = 'block'
}
```
```js
// ES6 单例
class Single {
	constructor (name, age) {
		this.name = name
		this.age = age
	}
	static getInstance (name, age) {
		if (!this.instance) {
			this.instance = new Single(name, age)
		}
		return this.instance
	}
}
let lyCom = Single.getInstance('lily', 20)
let lyComCom = Single.getInstance('lisa', 21)
console.log(lyCom === lyComCom) // true
```

#### 策略模式
- 定义一系列的算法，把他们封装起来，并且他们之间可以相互替换
- 核心：将算法的使用和算法的实现分离开来

#### 发布订阅模式
发布订阅模式又叫观察者模式，它定义对象间的一种一对多的依赖关系，当一个对象的状态发生改变时，所有依赖于它的对象都将得到通知 —— `先订阅再发布`
- 支持简单都广播通信，当对象状态发生改变时，会自动通知已经订阅过的对象
- 可以应用在异步编程中，替代回调函数，可以订阅ajax之后的事件，只需要订阅自己需要的部分
- 对象之间的松耦合，两个对象之间都互相不了解彼此，但是不影响通信，当有新的订阅者出现时，发布的代码无需改变，同样发布的代码改变，只要之前约定的事件名称没改变，也不影响订阅
- 可用于跨组件间传值

#### 数组扁平化处理
var arr = [1, [2, 3, [4, 5]], 4]
1. 使用`flat()`
```js
const res1 = arr.flat(Infinity)
```
2. 正则表达式
```js
const res2 = JSON.parse('[' + JSON.stringify(arr).replace(/\[|\]/g, '') + ']')
```
3. 使用`reduce`
```js
const flatten = arr => {
	return arr.reduce((pre, cur) => {
		return pre.concat(Array.isArray(cur)? flatten(cur) : cur)
	}, [])
}
```
4. 函数递归
```js
const res4 = []
const fn = arr => {
	for (let i = 0; i < arr.length; i++) {
		if (Array.isArray(arr[i])) {
			fn(arr[i])
		} else {
			res4.push(arr[i])
		}
	}
}
```

#### BFC
- BFC理解：块级格式化上下文，它是指一个独立的块级渲染区域，只有block-level BOX参与，该区域拥有一套渲染规则来约束块级盒子的布局，且与区域外部无关
- 从一个现象开始：1.一个盒子不设置height，当内容子元素都浮动时，无法撑起自身 2.这个盒子没有形成BFC
- 如何创建BFC：1.float的值不是none 2.position的值不是static或者relative 3.display的值是inline-block、flex或者inline-flex 4.overflow:hidden
- BFC的其他作用：1.BFC可以取消盒子margin塌陷 2.BFC可以阻止元素被浮动元素覆盖

#### reduce
```js
arr.reduce((prev, cur, index, arr) => {}, init)
arr.reduce((prev, cur, index, arr) => {})
```
- arr 表示原数组
- prev 表示上一次调用回调时返回的值，或者初始值init，第一次调用若没有init，则为数组第一个元素的值
- cur 表示当前正在处理的数组元素
- index 表示当前正在处理的数组元素的索引，若提供init值，index为0，否则为1
> 常用参数只有两个： prev cur
##### 使用场景：
- 数组求和，求乘积
- 计算数组中每个元素出现的次数
- 数组去重
- 将二维数组转化成一维数组
- 将多维数组转化成一维数组
- 对象里的属性求和

#### 原型链继承
- 直接让子类的原型对象指向父类的实例，当子类的实例找不到对象的属性和方法时，会沿着原型链/父类往上找
- 缺点：原型指向同一个parent实例，当有多个子对象时，修改其中一个会影响其他的子对象
```js
function Parent () {
	this.name = ['lisa']
}
Parent.prototype.getName = function () {
	return this.name
}
function Child () {
	
}
Child.prototype = new Parent()
Child.prototype.constructor = Child
const child1 = new Child()
const child2 = new Child()
child1.name[0] = 'apple'
console.log(child1.name) // ['apple']
console.log(child2.name) // ['apple']
```

#### 构造函数继承
- 在子类的构造函数之中去执行父类的构造函数，并且为其绑定子类的this
- 缺点：并不能继承父类原型上的方法和属性
```js
 function Parent (name) {
	 this.name = [name]
 }
 Parent.prototype.getName = function () {
	 return this.name
 }
 function Child () {
	 Parent.call(this, 'lisa')
 }
 var child1 = new Child()
 var child2 = new Child()
 child1.name[0] = 'apple'
 console.log(child1.name) // ['apple']
 console.log(child2.name) // ['lisa']
 console.log(child1.getName()) // Error，并不能继承父类原型上的方法和属性
```

#### 组合式继承
- 等于原型链继承+构造函数继承
- 缺点：每次创建实例都执行了父类构造函数
```js
function Parent (name) {
	this.name = [name]
}
Parent.prototype.getName = function () {
	return this.name
}
function Child () {
	Parent.call(this, 'lisa')
}
Child.prototype = new Parent()
Child.prototype.contructor = Child
var child1 = new Child()
var child2 = new Child()
child1.name[0] = 'apple'
console.log(child1.name) // [‘apple’]
console.log(child2.name) // ['lisa']
console.log(child2.getName()) // ['lisa']
```

#### 寄生式组合继承
- 缺点：父类原型直接赋值给子类原型，子类原型操作会影响父类原型
```js
function Parent (name) {
	this.name = [name]
}
Parent.prototype.getName = function () {
	return this.name
}
function Child () {
	Parent.call(this, 'lisa')
}
// Child.prototype = Parent.prototype => 子类原型操作会影响父类原型
Child.prototype = Object.create(Parent.prototype) // Object.create创建一个新对象
Child.prototype.constructor = Child
const child1 = new Child()
const Child2 = new Child()
child1.name[0] = 'apple'
console.log(child1.name) // ['apple']
console.log(child2.name) // ['lisa']
console.log(child2.getName()) // ['lisa']
```

#### 使用js编写更好都条件语句
1. 数组方法 Array.includes
2. 提前退出/提前返回
3. 对象字面量代替switch语句
4. 默认参数结构
5. 用上Array.some Array.every

